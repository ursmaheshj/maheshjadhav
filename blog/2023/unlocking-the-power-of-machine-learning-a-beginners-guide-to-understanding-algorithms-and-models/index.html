<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>Oh man, learning machine learning can be quite an adventure! As I dive into its depths, I realized just how complex and confusing it can be. With the plethora of models and algorithms involved, understanding each one can feel like a never-ending journey. And don’t even get me started on the challenge of perfectly understanding each individual algorithm, as soon as I began to understand a new algorithm, I found myself forgetting the earlier ones. It was like trying to figure out the timeline of the Marvel Cinematic Universe. So, I asked myself, “What can I do to make sense of this madness?” And that’s when I had an Idea.</p> <p>I decided to take an eagle’s-eye view of the situation and created a map of algorithms depicting machine learning, complete with all its subsets and famous models. This gave me a broader understanding of which algorithm belongs to what model. I also wrote down the description of each algorithm as briefly as possible, giving me an instant idea of its purpose.</p> <p>This approach actually worked! It helped me to understand and grasp the machine learning models more easily, and I’m confident it can do the same for you too. So, take a deep breath, put on your earbuds, and let’s tackle machine learning together!</p> <p><strong>Machine learning </strong>is a branch of <a href="https://towardsdatascience.com/introductory-guide-to-artificial-intelligence-11fc04cea042" rel="external nofollow noopener" target="_blank"><em>Artificial Intelligence (AI)</em></a> and computer science that involves statistical and mathematical approaches to find patterns and insights into the data which is then used for building algorithms and models that can learn and make predictions without external instructions. There are many machine learning algorithms that can be broadly classified into 4 types <em>Supervised learning, Unsupervised Learning, Semi-Supervised learning, </em>and<em> Reinforcement learning</em> as shown below.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*eMj6PTmHUw2RlR8RIZTagg.jpeg"><figcaption>Types of Machine Learning Models</figcaption></figure> <h3>Supervised Machine Learning</h3> <p>It is a type of machine learning model where algorithms are trained on labeled data to learn the relationships between feature matrix and target variable so that it can make accurate predictions on new, unseen data.</p> <h4>Regression Model</h4> <p>It provides a set of statistical processes to describe the relationship between independent variables and dependent (target) variables.</p> <ul> <li> <strong>Linear</strong> <strong>Regression:</strong> It is used to predict the value of a continuous dependent variable based on one or more independent variables with the help of a best fit linear line that minimizes the difference between predicted values and the actual values.</li> <li> <strong>Logistic Regression:</strong> It uses a sigmoid function to estimate the probability of an event occurring based on a given dataset of independent variables. It is primarily used for binary classification problems where the output variable can only take two values (0 | 1).</li> </ul> <h4>Classification Model</h4> <p>Supervised machine learning method where algorithm tries to predict or classify data into predefined categories based on characteristics.</p> <ul> <li> <strong>Decision Tree:</strong> A specific type of probability tree where each node represents a Yes|No type of question and the branch represents outcome of test that enables the algorithm to make decisions.</li> <li> <strong>Random Forest:</strong> It creates multiple decision trees using a random subset of training data and a random subset of features, which are then combined to make a final prediction.</li> <li> <strong>KNN (K-Nearest Neighbor):</strong> It is a non-parametric supervised learning method which calculates the K closest neighbors of a given data point in the training set, and then identifies the majority class among those neighbors as the predicted class for that data point. K’s value is a hyperparameter that can be adjusted to improve algorithm’s efficiency.</li> <li> <strong>SVM (Support Vector Machine):</strong> SVM tries to separate data by drawing a plane between them. We choose the plane in such a way that it creates the largest possible gap between the two types of data. This gap is called the margin. The points closest to the plane are called support vectors. By using these support vectors, we can classify new data into one of the two groups.</li> <li> <strong>Naive Bayes Classification:</strong> It predicts outcomes based on a set of input features. It uses probability theory to determine the likelihood of an outcome based on the presence or absence of certain features. The “naive” part of its name comes from the assumption that each feature is independent of the others, which simplifies the calculations.</li> </ul> <h3>Unsupervised Machine Learning</h3> <p>Type of Machine learning technique where the algorithm learns to recognize patterns in the data without the use of labeled examples or external guidance.</p> <h4>Clustering Models</h4> <p>These are machine learning models used to group similar data points together based on their features. They don’t rely on labeled data to make predictions. Instead, they try to find patterns and relationships in the data on their own.</p> <ul> <li> <strong>K - Means Clustering:</strong> This algorithm partitions the dataset into K-Clusters where K is a predefined number. Its goal is to optimize the sum of squared distance between data points and their assigned cluster centroid.</li> <li> <strong>Hierarchical Model:</strong> This method starts by considering each item as its own cluster, and then repeatedly merges the closest pairs of clusters until all items are in a single group. The resulting tree can be cut at different levels to obtain different levels of clustering. It is useful for exploring relationships between items in a dataset and identifying natural groupings using a tree-like structure called a dendrogram.</li> <li> <strong>DBSCAN:</strong> Density-based spatial clustering of applications with noise does not require the number of clusters to be specified beforehand. Instead, it determines clusters based on the density of points in the data set. Points that are close together and have high density are considered part of the same cluster, while points that are isolated or have low density are classified as noise.</li> <li> <strong>GMM (Gaussian Mixture Model):</strong> It assumes that the data comes from a mixture of many Gaussian distributions. Each of these distributions represents a different group or cluster in the data. The model tries to estimate the parameters of these distributions (such as mean and variance) and the probability of each data point belonging to each distribution</li> <li> <strong>Spectral Clustering Model:</strong> It creates a similarity graph of the data set, where each data point is represented as a node in the graph and the edges between the nodes represent their pairwise similarity. Spectral clustering then uses the graph’s spectral properties to identify clusters in the data by finding the eigenvectors (principal components) of the graph’s Laplacian matrix to project data into lower-dimensional space, where it is easier to identify clusters.</li> <li> <strong>Mean-Shift Clustering:</strong> It works by finding the centroids or mean points of each cluster by shifting a window around the data space to the areas of higher density. The window shifts towards the steepest ascent until it reaches a peak where the density is highest, and this peak is then designated as the centroid of the cluster. The window is again moved to a new peak and this process is repeated until all centroids are found.</li> <li> <strong>SOM (Self-Organizing Map):</strong> It is a type of artificial neural network that works by mapping a high-dimensional data set onto a low-dimensional grid of neurons in a way that preserves the topological relationship between the data points. Each neuron in the grid represents a cluster or a group of similar data points.</li> </ul> <h4>Dimensionality Reduction Models</h4> <p>These are techniques in machine learning that simplify complex data sets by reducing the number of features or variables while retaining the most important information. They help to remove noise and redundant information from the data, making it easier to analyze and visualize.</p> <ul> <li> <strong>PCA (Principal Component Analysis):</strong> It transforms the data set into a new coordinate system, where the new axes represent principal components that capture the maximum variance in the data. These principal components are linear combinations of the original features, and they are ordered by the amount of variance they explain in the data. By projecting the data onto the first few principal components, PCA can reduce the dimensionality while retaining most important information.</li> <li> <strong>NMF (Non-negative Matrix Factorization): </strong>It works by factorizing a non-negative matrix (V) into two lower-rank non-negative matrices W and H, such that V=WH. Here, V is a data matrix with rows representing samples and columns representing features, W is a basis matrix with rows representing basis vectors, and H is a coefficient matrix with columns representing coefficients.</li> <li> <strong>LDA (Linear Discriminant Analysis):</strong> It works by finding a linear combination of features that maximizes the separation between different classes or categories in the data. By projecting the data onto this new linear subspace, LDA can reduce the dimensionality of the data while retaining the most important information for classification.</li> <li> <strong>ICA (Independent Component Analysis):</strong> It finds a set of independent components that represent the underlying sources of variation in a complex data set. By separating the data into its independent components, ICA can reduce the dimensionality of the data and extract the most important features or signals.</li> <li> <strong>Autoencoder:</strong> It works by compressing the input data into a lower-dimensional representation, and then reconstructing it back to its original form. By minimizing the difference between the input and output data, the autoencoder can learn a compact and informative representation of the input data.</li> </ul> <h3>Semi-Supervised Learning</h3> <p>A machine learning approach where a model is trained on a combination of labeled and unlabeled data. In this approach, the labeled data is used to teach the model to recognize patterns and make predictions, while the unlabeled data is used to improve the model’s generalization and robustness.</p> <ul> <li> <strong>Self-Training Model:</strong> The model is trained on a small set of labeled data, and then used to predict the labels of a larger set of unlabeled data. The predicted labels are then added to the labeled dataset, and the model is retrained on the expanded dataset. This process is repeated iteratively, with the model learning from its own predictions and gradually improving its accuracy on the unlabeled data.</li> <li> <strong>Co-Training Model:</strong> Two separate models are trained on different subsets of data, one with labeled data and the other with unlabeled data. The models exchange information by using their own predictions as additional labeled data for the other model. This iterative process is repeated, with the models learning from each other’s predictions and gradually improving their accuracy on the unlabeled data.</li> <li> <strong>Generative Model:</strong> The model learns to identify patterns in the labeled data and then uses those patterns to generate new examples. These generated examples are then used to improve the model’s performance on the unlabeled data.</li> <li> <strong>Label Propagation:</strong> It learns from both labeled and unlabeled data to make predictions on the unlabeled data. The model first assigns labels to the labeled data and then propagates these labels to the unlabeled data based on the similarity between data points. The model iteratively updates the labels of the unlabeled data until a certain convergence criterion is met.</li> <li> <strong>Semi-Supervised Clustering:</strong> The model uses the labeled data to learn the initial structure of the clusters and then groups the unlabeled data points based on their similarity to the labeled data points. The model iteratively refines the clustering results using both labeled and unlabeled data until the goal is reached.</li> </ul> <h3>Reinforcement Learning</h3> <p>It is a machine learning technique that involves training an agent to make decisions in an environment to maximize a reward. The agent learns through trial and error, receiving feedback in the form of rewards or penalties based on its actions. The goal is for the agent to learn the optimal policy, or sequence of actions, that will result in the highest total reward over time.</p> <h4>Model-Based Learning</h4> <p>It involves learning a model of the environment in addition to learning the optimal policy. The model is a representation of the dynamics of the environment, which the agent can use to predict the next state and reward given the current state and action. The agent can then use these predictions to plan ahead and select the action that will lead to the highest expected reward.</p> <ul> <li> <strong>MPC (Model Predictive Control):</strong> In this algorithm the agent solves an optimization problem at each time step, using the predictive model to simulate future states and rewards. The solution to the optimization problem gives the best sequence of actions to take in the immediate future. MPC is useful when the environment is complex and has a long time horizon, as it allows the agent to plan ahead and make optimal decisions based on predicted outcomes.</li> <li> <strong>DP (Dynamic Programming): </strong>It involves learning a value function or a policy by solving a system of Bellman equations. It works by iteratively updating the value of each state based on the values of its neighboring states, until convergence. This method is best suited for environments with known dynamics, where the optimal policy can be computed analytically.</li> <li> <strong>iLQR (iterative Linear Quadratic Regulator):</strong> It is used to solve optimal control problems. It involves iteratively solving a set of linear-quadratic subproblems to find a sequence of control inputs that minimizes a cost function while satisfying a set of constraints. It is often used in robotics and control systems to find optimal control policies for complex systems.</li> <li> <strong>Dyna-Q:</strong> It is a model-based reinforcement learning algorithm used to find the optimal action policy in a Markov decision process (MDP). It combines model-free and model-based methods to make predictions and learn from experience. It maintains a Q-table to approximate the optimal action-value function and also learns a model of the environment to plan future actions.</li> </ul> <h4>Model-Free Learning</h4> <p>technique where an agent learns to make decisions through trial and error without having explicit knowledge of the environment or a model of it. The agent learns by directly interacting with the environment and updating its policy based on the observed rewards.</p> <ul> <li> <strong>Q-Learning:</strong> It enables an agent to learn to make optimal decisions in an environment by finding the best actions to take based on the current state. The algorithm updates its Q-values, which represent the expected reward for taking a particular action in a particular state, through trial and error by exploring the environment and receiving rewards. The agent continues to learn and improve its decision-making skills over time by adjusting its Q-values based on the rewards it receives, and ultimately, it aims to learn the optimal policy for maximizing long-term rewards.</li> <li> <strong>SARSA</strong> <strong>(State-Action-Reward-State-Action):</strong> It learns from experiences (trial and error). The agent interacts with the environment, and at each time step, it observes the current state, takes an action, receives a reward, and observes the next state. SARSA algorithm updates its Q-values based on the current observed state, the action taken, the reward received, and the next state and the action that the agent chooses. Unlike Q-Learning, SARSA uses the same policy to select actions during learning and execution, making it an on-policy algorithm.</li> <li> <strong>DQN (Deep Q-network): </strong>This algorithm combines the Q-learning algorithm with deep neural networks. It is used to solve problems where the state space is too large to be handled by traditional Q-learning. The DQN algorithm works by approximating the Q-value function using a deep neural network and uses it to update the Q-values iteratively. The neural network is trained on the experiences collected from the environment using a technique called experience replay.</li> <li> <strong>Monte Carlo Method:</strong> It uses repeated random sampling to estimate the value of an action in a given state. It does not require knowledge of the transition probabilities between states or the rewards associated with taking actions. Instead, it learns by randomly exploring the environment and accumulating rewards over time to update the Q-values of each action-state pair.</li> <li> <strong>Policy Gradient Method:</strong> It involves training a neural network to directly output the policy that maximizes the expected reward. Unlike value-based methods such as Q-learning, policy gradient methods do not estimate the value of each action, but instead optimize the policy directly. The algorithm uses stochastic gradient descent to update the parameters of the policy network to maximize the expected reward.</li> <li> <strong>Actor-Critic Method:</strong> Type of reinforcement learning where there are two models working together: the actor, which decides on actions to take, and the critic, which evaluates the actions taken by the actor. The actor model determines the best action to take in a given state, and the critic model evaluates how good the chosen action is. By working together, the actor-critic method aims to learn an optimal policy that maximizes rewards over time.</li> </ul> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=72167d30f2ce" width="1" height="1" alt=""></p> </body></html>